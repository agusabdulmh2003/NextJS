{"version":3,"sources":["useVirtualizer.ts"],"sourcesContent":["import { useIntersectionObserver } from '../../hooks/useIntersectionObserver';\nimport type { ReactNode } from 'react';\nimport { useEffect, useRef, useCallback, useReducer } from 'react';\n\nimport type { VirtualizerProps, VirtualizerState } from './Virtualizer.types';\nimport { resolveShorthand } from '@fluentui/react-utilities';\nimport { flushSync } from 'react-dom';\n\nimport { useVirtualizerContextState_unstable } from '../../Utilities';\nimport { renderVirtualizerChildPlaceholder } from './renderVirtualizer';\n\nexport function useVirtualizer_unstable(props: VirtualizerProps): VirtualizerState {\n  const {\n    itemSize,\n    numItems,\n    virtualizerLength,\n    children: renderChild,\n    getItemSize,\n    bufferItems = Math.round(virtualizerLength / 4.0),\n    bufferSize = Math.floor(bufferItems / 2.0) * itemSize,\n    scrollViewRef,\n    axis = 'vertical',\n    reversed = false,\n    virtualizerContext,\n  } = props;\n\n  /* The context is optional, it's useful for injecting additional index logic, or performing uniform state updates*/\n  const _virtualizerContext = useVirtualizerContextState_unstable(virtualizerContext);\n\n  const actualIndex = _virtualizerContext.contextIndex;\n  const setActualIndex = _virtualizerContext.setContextIndex;\n\n  // Store ref to before padding element\n  const beforeElementRef = useRef<Element | null>(null);\n\n  // Store ref to before padding element\n  const afterElementRef = useRef<Element | null>(null);\n\n  // We need to store an array to track dynamic sizes, we can use this to incrementally update changes\n  const childSizes = useRef<number[]>(new Array<number>(getItemSize ? numItems : 0));\n\n  /* We keep track of the progressive sizing/placement down the list,\n  this helps us skip re-calculations unless children/size changes */\n  const childProgressiveSizes = useRef<number[]>(new Array<number>(getItemSize ? numItems : 0));\n\n  // The internal tracking REF for child array (updates often).\n  const childArray = useRef<ReactNode[]>(new Array(virtualizerLength));\n\n  // We want to be methodical about updating the render with child reference array\n  const forceUpdate = useReducer(() => ({}), {})[1];\n\n  const horizontal = axis === 'horizontal';\n\n  const populateSizeArrays = () => {\n    if (!getItemSize) {\n      // Static sizes, never mind!\n      return;\n    }\n\n    if (numItems !== childSizes.current.length) {\n      childSizes.current = new Array<number>(numItems);\n    }\n\n    if (numItems !== childProgressiveSizes.current.length) {\n      childProgressiveSizes.current = new Array<number>(numItems);\n    }\n\n    for (let index = 0; index < numItems; index++) {\n      childSizes.current[index] = getItemSize(index);\n      if (index === 0) {\n        childProgressiveSizes.current[index] = childSizes.current[index];\n      } else {\n        childProgressiveSizes.current[index] = childProgressiveSizes.current[index - 1] + childSizes.current[index];\n      }\n    }\n  };\n\n  const batchUpdateNewIndex = (index: number) => {\n    // Local updates\n    updateChildRows(index);\n    updateCurrentItemSizes(index);\n\n    // State setters\n    setActualIndex(index);\n  };\n\n  // Observe intersections of virtualized components\n  const { setObserverList } = useIntersectionObserver(\n    (entries: IntersectionObserverEntry[], observer: IntersectionObserver) => {\n      /* Sanity check - do we even need virtualization? */\n      if (virtualizerLength > numItems) {\n        if (actualIndex !== 0) {\n          batchUpdateNewIndex(0);\n        }\n        // No-op\n        return;\n      }\n\n      /* IO initiates this function when needed (bookend entering view) */\n      let measurementPos = 0;\n      let bufferCount = bufferItems;\n\n      // Grab latest entry that is intersecting\n      const latestEntry =\n        entries.length === 1\n          ? entries[0]\n          : entries\n              .sort((entry1, entry2) => entry2.time - entry1.time)\n              .find(entry => {\n                return entry.intersectionRatio > 0;\n              });\n\n      if (!latestEntry) {\n        // If we don't find an intersecting area, ignore for now.\n        return;\n      }\n\n      if (latestEntry.target === afterElementRef.current) {\n        // We need to inverse the buffer count\n        bufferCount = virtualizerLength - bufferItems;\n        measurementPos = reversed ? calculateAfter() : calculateTotalSize() - calculateAfter();\n        if (!horizontal) {\n          if (reversed) {\n            // Scrolling 'up' and hit the after element below\n            measurementPos -= Math.abs(latestEntry.boundingClientRect.bottom);\n          } else if (latestEntry.boundingClientRect.top < 0) {\n            // Scrolling 'down' and hit the after element above top: 0\n            measurementPos -= latestEntry.boundingClientRect.top;\n          }\n        } else {\n          if (reversed) {\n            // Scrolling 'left' and hit the after element\n            measurementPos -= Math.abs(latestEntry.boundingClientRect.right);\n          } else if (latestEntry.boundingClientRect.left < 0) {\n            // Scrolling 'right' and hit the after element\n            measurementPos -= latestEntry.boundingClientRect.left;\n          }\n        }\n      } else if (latestEntry.target === beforeElementRef.current) {\n        measurementPos = reversed ? calculateTotalSize() - calculateBefore() : calculateBefore();\n        if (!horizontal) {\n          if (!reversed) {\n            measurementPos -= Math.abs(latestEntry.boundingClientRect.bottom);\n          } else if (latestEntry.boundingClientRect.top < 0) {\n            // Scrolling 'down' in reverse order and hit the before element above top: 0\n            measurementPos -= latestEntry.boundingClientRect.top;\n          }\n        } else {\n          if (!reversed) {\n            measurementPos -= Math.abs(latestEntry.boundingClientRect.right);\n          } else if (latestEntry.boundingClientRect.left < 0) {\n            // Scrolling 'left' and hit before element\n            measurementPos -= latestEntry.boundingClientRect.left;\n          }\n        }\n      }\n\n      if (reversed) {\n        // We're reversed, up is down, left is right, invert the scroll measure.\n        measurementPos = Math.max(calculateTotalSize() - Math.abs(measurementPos), 0);\n      }\n\n      // For now lets use hardcoded size to assess current element to paginate on\n      const startIndex = getIndexFromScrollPosition(measurementPos);\n      const bufferedIndex = Math.max(startIndex - bufferCount, 0);\n\n      // Safety limits\n      const maxIndex = Math.max(numItems - virtualizerLength, 0);\n      const newStartIndex = Math.min(Math.max(bufferedIndex, 0), maxIndex);\n\n      if (actualIndex !== newStartIndex) {\n        // We flush sync this and perform an immediate state update\n        flushSync(() => {\n          batchUpdateNewIndex(newStartIndex);\n        });\n      }\n    },\n    {\n      root: scrollViewRef ? scrollViewRef?.current : null,\n      rootMargin: '0px',\n      threshold: 0,\n    },\n  );\n\n  const findIndexRecursive = (scrollPos: number, lowIndex: number, highIndex: number): number => {\n    if (lowIndex > highIndex) {\n      // We shouldn't get here - but no-op the index if we do.\n      return actualIndex;\n    }\n    const midpoint = Math.floor((lowIndex + highIndex) / 2);\n    const iBefore = Math.max(midpoint - 1, 0);\n    const iAfter = Math.min(midpoint + 1, childProgressiveSizes.current.length - 1);\n    const indexValue = childProgressiveSizes.current[midpoint];\n    const afterIndexValue = childProgressiveSizes.current[iAfter];\n    const beforeIndexValue = childProgressiveSizes.current[iBefore];\n    if (scrollPos <= afterIndexValue && scrollPos >= beforeIndexValue) {\n      /* We've found our index - if we are exactly matching before/after index that's ok,\n      better to reduce checks if it's right on the boundary. */\n      return midpoint;\n    }\n\n    if (indexValue > scrollPos) {\n      return findIndexRecursive(scrollPos, lowIndex, midpoint - 1);\n    } else {\n      return findIndexRecursive(scrollPos, midpoint + 1, highIndex);\n    }\n  };\n\n  const getIndexFromSizeArray = (scrollPos: number): number => {\n    /* Quick searches our progressive height array */\n    if (\n      scrollPos === 0 ||\n      childProgressiveSizes.current.length === 0 ||\n      scrollPos <= childProgressiveSizes.current[0]\n    ) {\n      // Check start\n      return 0;\n    }\n\n    if (scrollPos >= childProgressiveSizes.current[childProgressiveSizes.current.length - 1]) {\n      // Check end\n      return childProgressiveSizes.current.length - 1;\n    }\n\n    return findIndexRecursive(scrollPos, 0, childProgressiveSizes.current.length - 1);\n  };\n\n  const getIndexFromScrollPosition = (scrollPos: number) => {\n    if (!getItemSize) {\n      return Math.round(scrollPos / itemSize);\n    }\n\n    return getIndexFromSizeArray(scrollPos);\n  };\n\n  const calculateTotalSize = () => {\n    if (!getItemSize) {\n      return itemSize * numItems;\n    }\n\n    // Time for custom size calcs\n    return childProgressiveSizes.current[numItems - 1];\n  };\n\n  const calculateBefore = () => {\n    const currentIndex = Math.min(actualIndex, numItems);\n\n    if (!getItemSize) {\n      // The missing items from before virtualization starts height\n      return currentIndex * itemSize;\n    }\n\n    if (currentIndex <= 0) {\n      return 0;\n    }\n\n    // Time for custom size calcs\n    return childProgressiveSizes.current[currentIndex - 1];\n  };\n\n  const calculateAfter = () => {\n    if (numItems === 0) {\n      return 0;\n    }\n\n    const lastItemIndex = Math.min(actualIndex + virtualizerLength, numItems - 1);\n    if (!getItemSize) {\n      // The missing items from after virtualization ends height\n      const remainingItems = numItems - lastItemIndex - 1;\n      return remainingItems * itemSize;\n    }\n\n    // Time for custom size calcs\n    return childProgressiveSizes.current[numItems - 1] - childProgressiveSizes.current[lastItemIndex];\n  };\n\n  const updateChildRows = useCallback(\n    (newIndex: number) => {\n      if (numItems === 0) {\n        /* Nothing to virtualize */\n\n        return [];\n      }\n\n      if (childArray.current.length !== numItems) {\n        childArray.current = new Array(virtualizerLength);\n      }\n      const _actualIndex = Math.max(newIndex, 0);\n      const end = Math.min(_actualIndex + virtualizerLength, numItems);\n\n      for (let i = _actualIndex; i < end; i++) {\n        childArray.current[i - _actualIndex] = renderVirtualizerChildPlaceholder(renderChild(i), i);\n      }\n    },\n    [numItems, renderChild, virtualizerLength],\n  );\n\n  const setBeforeRef = useCallback(\n    (element: HTMLDivElement) => {\n      if (!element || beforeElementRef.current === element) {\n        return;\n      }\n      beforeElementRef.current = element;\n      const newList = [];\n\n      newList.push(beforeElementRef.current);\n\n      if (afterElementRef.current) {\n        newList.push(afterElementRef.current);\n      }\n\n      // Ensure we update array if before element changed\n      setObserverList(newList);\n    },\n    [setObserverList],\n  );\n\n  const setAfterRef = useCallback(\n    (element: HTMLDivElement) => {\n      if (!element || afterElementRef.current === element) {\n        return;\n      }\n      afterElementRef.current = element;\n      const newList = [];\n\n      if (beforeElementRef.current) {\n        newList.push(beforeElementRef.current);\n      }\n\n      newList.push(afterElementRef.current);\n\n      // Ensure we update array if after element changed\n      setObserverList(newList);\n    },\n    [setObserverList],\n  );\n\n  const updateCurrentItemSizes = (newIndex: number) => {\n    if (!getItemSize) {\n      // Static sizes, not required.\n      return;\n    }\n    // We should always call our size function on index change (only for the items that will be rendered)\n    // This ensures we request the latest data for incoming items in case sizing has changed.\n    const endIndex = Math.min(newIndex + virtualizerLength, numItems);\n    const startIndex = Math.max(newIndex, 0);\n\n    let didUpdate = false;\n    for (let i = startIndex; i < endIndex; i++) {\n      const newSize = getItemSize(i);\n      if (newSize !== childSizes.current[i]) {\n        childSizes.current[i] = newSize;\n        didUpdate = true;\n      }\n    }\n\n    if (didUpdate) {\n      // Update our progressive size array\n      for (let i = startIndex; i < numItems; i++) {\n        const prevSize = i > 0 ? childProgressiveSizes.current[i - 1] : 0;\n        childProgressiveSizes.current[i] = prevSize + childSizes.current[i];\n      }\n    }\n  };\n\n  // Initialize the size array before first render.\n  const hasInitialized = useRef<boolean>(false);\n  const initializeSizeArray = () => {\n    if (hasInitialized.current === false) {\n      hasInitialized.current = true;\n      populateSizeArrays();\n    }\n  };\n\n  // Initialization on mount - update array index to 0 (ready state).\n  // Only fire on mount (no deps).\n  useEffect(() => {\n    if (actualIndex < 0) {\n      batchUpdateNewIndex(0);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  // If the user passes in an updated renderChild function - update current children\n  useEffect(() => {\n    if (actualIndex >= 0) {\n      updateChildRows(actualIndex);\n      forceUpdate();\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [renderChild, updateChildRows]);\n\n  useEffect(() => {\n    // Ensure we repopulate if getItemSize callback changes\n    populateSizeArrays();\n\n    // We only run this effect on getItemSize change (recalc dynamic sizes)\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [getItemSize]);\n\n  // Ensure we have run through and updated the whole size list array at least once.\n  initializeSizeArray();\n\n  if (getItemSize && (numItems !== childSizes.current.length || numItems !== childProgressiveSizes.current.length)) {\n    // Child length mismatch, repopulate size arrays.\n    populateSizeArrays();\n  }\n\n  // Ensure we recalc if virtualizer length changes\n  const maxCompare = Math.min(virtualizerLength, numItems);\n  if (childArray.current.length !== maxCompare && actualIndex + childArray.current.length < numItems) {\n    updateChildRows(actualIndex);\n  }\n\n  const isFullyInitialized = hasInitialized.current && actualIndex >= 0;\n  return {\n    components: {\n      before: 'div',\n      after: 'div',\n      beforeContainer: 'div',\n      afterContainer: 'div',\n    },\n    virtualizedChildren: childArray.current,\n    before: resolveShorthand(props.before, {\n      required: true,\n      defaultProps: {\n        ref: setBeforeRef,\n        role: 'none',\n      },\n    }),\n    after: resolveShorthand(props.after, {\n      required: true,\n      defaultProps: {\n        ref: setAfterRef,\n        role: 'none',\n      },\n    }),\n    beforeContainer: resolveShorthand(props.beforeContainer, {\n      required: true,\n      defaultProps: {\n        role: 'none',\n      },\n    }),\n    afterContainer: resolveShorthand(props.afterContainer, {\n      required: true,\n      defaultProps: {\n        role: 'none',\n      },\n    }),\n    beforeBufferHeight: isFullyInitialized ? calculateBefore() : 0,\n    afterBufferHeight: isFullyInitialized ? calculateAfter() : 0,\n    totalVirtualizerHeight: isFullyInitialized ? calculateTotalSize() : virtualizerLength * itemSize,\n    virtualizerStartIndex: actualIndex,\n    axis,\n    bufferSize,\n    reversed,\n  };\n}\n"],"names":["useIntersectionObserver","useEffect","useRef","useCallback","useReducer","resolveShorthand","flushSync","useVirtualizerContextState_unstable","renderVirtualizerChildPlaceholder","useVirtualizer_unstable","props","itemSize","numItems","virtualizerLength","children","renderChild","getItemSize","bufferItems","Math","round","bufferSize","floor","scrollViewRef","axis","reversed","virtualizerContext","_virtualizerContext","actualIndex","contextIndex","setActualIndex","setContextIndex","beforeElementRef","afterElementRef","childSizes","Array","childProgressiveSizes","childArray","forceUpdate","horizontal","populateSizeArrays","current","length","index","batchUpdateNewIndex","updateChildRows","updateCurrentItemSizes","setObserverList","entries","observer","measurementPos","bufferCount","latestEntry","sort","entry1","entry2","time","find","entry","intersectionRatio","target","calculateAfter","calculateTotalSize","abs","boundingClientRect","bottom","top","right","left","calculateBefore","max","startIndex","getIndexFromScrollPosition","bufferedIndex","maxIndex","newStartIndex","min","root","rootMargin","threshold","findIndexRecursive","scrollPos","lowIndex","highIndex","midpoint","iBefore","iAfter","indexValue","afterIndexValue","beforeIndexValue","getIndexFromSizeArray","currentIndex","lastItemIndex","remainingItems","newIndex","_actualIndex","end","i","setBeforeRef","element","newList","push","setAfterRef","endIndex","didUpdate","newSize","prevSize","hasInitialized","initializeSizeArray","maxCompare","isFullyInitialized","components","before","after","beforeContainer","afterContainer","virtualizedChildren","required","defaultProps","ref","role","beforeBufferHeight","afterBufferHeight","totalVirtualizerHeight","virtualizerStartIndex"],"mappings":"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"}
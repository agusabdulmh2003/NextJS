{"version":3,"sources":["useVirtualizer.js"],"sourcesContent":["import { useIntersectionObserver } from '../../hooks/useIntersectionObserver';\nimport { useEffect, useRef, useCallback, useReducer } from 'react';\nimport { resolveShorthand } from '@fluentui/react-utilities';\nimport { flushSync } from 'react-dom';\nimport { useVirtualizerContextState_unstable } from '../../Utilities';\nimport { renderVirtualizerChildPlaceholder } from './renderVirtualizer';\nexport function useVirtualizer_unstable(props) {\n    const { itemSize , numItems , virtualizerLength , children: renderChild , getItemSize , bufferItems =Math.round(virtualizerLength / 4.0) , bufferSize =Math.floor(bufferItems / 2.0) * itemSize , scrollViewRef , axis ='vertical' , reversed =false , virtualizerContext  } = props;\n    /* The context is optional, it's useful for injecting additional index logic, or performing uniform state updates*/ const _virtualizerContext = useVirtualizerContextState_unstable(virtualizerContext);\n    const actualIndex = _virtualizerContext.contextIndex;\n    const setActualIndex = _virtualizerContext.setContextIndex;\n    // Store ref to before padding element\n    const beforeElementRef = useRef(null);\n    // Store ref to before padding element\n    const afterElementRef = useRef(null);\n    // We need to store an array to track dynamic sizes, we can use this to incrementally update changes\n    const childSizes = useRef(new Array(getItemSize ? numItems : 0));\n    /* We keep track of the progressive sizing/placement down the list,\n  this helps us skip re-calculations unless children/size changes */ const childProgressiveSizes = useRef(new Array(getItemSize ? numItems : 0));\n    // The internal tracking REF for child array (updates often).\n    const childArray = useRef(new Array(virtualizerLength));\n    // We want to be methodical about updating the render with child reference array\n    const forceUpdate = useReducer(()=>({}), {})[1];\n    const horizontal = axis === 'horizontal';\n    const populateSizeArrays = ()=>{\n        if (!getItemSize) {\n            // Static sizes, never mind!\n            return;\n        }\n        if (numItems !== childSizes.current.length) {\n            childSizes.current = new Array(numItems);\n        }\n        if (numItems !== childProgressiveSizes.current.length) {\n            childProgressiveSizes.current = new Array(numItems);\n        }\n        for(let index = 0; index < numItems; index++){\n            childSizes.current[index] = getItemSize(index);\n            if (index === 0) {\n                childProgressiveSizes.current[index] = childSizes.current[index];\n            } else {\n                childProgressiveSizes.current[index] = childProgressiveSizes.current[index - 1] + childSizes.current[index];\n            }\n        }\n    };\n    const batchUpdateNewIndex = (index)=>{\n        // Local updates\n        updateChildRows(index);\n        updateCurrentItemSizes(index);\n        // State setters\n        setActualIndex(index);\n    };\n    // Observe intersections of virtualized components\n    const { setObserverList  } = useIntersectionObserver((entries, observer)=>{\n        /* Sanity check - do we even need virtualization? */ if (virtualizerLength > numItems) {\n            if (actualIndex !== 0) {\n                batchUpdateNewIndex(0);\n            }\n            // No-op\n            return;\n        }\n        /* IO initiates this function when needed (bookend entering view) */ let measurementPos = 0;\n        let bufferCount = bufferItems;\n        // Grab latest entry that is intersecting\n        const latestEntry = entries.length === 1 ? entries[0] : entries.sort((entry1, entry2)=>entry2.time - entry1.time).find((entry)=>{\n            return entry.intersectionRatio > 0;\n        });\n        if (!latestEntry) {\n            // If we don't find an intersecting area, ignore for now.\n            return;\n        }\n        if (latestEntry.target === afterElementRef.current) {\n            // We need to inverse the buffer count\n            bufferCount = virtualizerLength - bufferItems;\n            measurementPos = reversed ? calculateAfter() : calculateTotalSize() - calculateAfter();\n            if (!horizontal) {\n                if (reversed) {\n                    // Scrolling 'up' and hit the after element below\n                    measurementPos -= Math.abs(latestEntry.boundingClientRect.bottom);\n                } else if (latestEntry.boundingClientRect.top < 0) {\n                    // Scrolling 'down' and hit the after element above top: 0\n                    measurementPos -= latestEntry.boundingClientRect.top;\n                }\n            } else {\n                if (reversed) {\n                    // Scrolling 'left' and hit the after element\n                    measurementPos -= Math.abs(latestEntry.boundingClientRect.right);\n                } else if (latestEntry.boundingClientRect.left < 0) {\n                    // Scrolling 'right' and hit the after element\n                    measurementPos -= latestEntry.boundingClientRect.left;\n                }\n            }\n        } else if (latestEntry.target === beforeElementRef.current) {\n            measurementPos = reversed ? calculateTotalSize() - calculateBefore() : calculateBefore();\n            if (!horizontal) {\n                if (!reversed) {\n                    measurementPos -= Math.abs(latestEntry.boundingClientRect.bottom);\n                } else if (latestEntry.boundingClientRect.top < 0) {\n                    // Scrolling 'down' in reverse order and hit the before element above top: 0\n                    measurementPos -= latestEntry.boundingClientRect.top;\n                }\n            } else {\n                if (!reversed) {\n                    measurementPos -= Math.abs(latestEntry.boundingClientRect.right);\n                } else if (latestEntry.boundingClientRect.left < 0) {\n                    // Scrolling 'left' and hit before element\n                    measurementPos -= latestEntry.boundingClientRect.left;\n                }\n            }\n        }\n        if (reversed) {\n            // We're reversed, up is down, left is right, invert the scroll measure.\n            measurementPos = Math.max(calculateTotalSize() - Math.abs(measurementPos), 0);\n        }\n        // For now lets use hardcoded size to assess current element to paginate on\n        const startIndex = getIndexFromScrollPosition(measurementPos);\n        const bufferedIndex = Math.max(startIndex - bufferCount, 0);\n        // Safety limits\n        const maxIndex = Math.max(numItems - virtualizerLength, 0);\n        const newStartIndex = Math.min(Math.max(bufferedIndex, 0), maxIndex);\n        if (actualIndex !== newStartIndex) {\n            // We flush sync this and perform an immediate state update\n            flushSync(()=>{\n                batchUpdateNewIndex(newStartIndex);\n            });\n        }\n    }, {\n        root: scrollViewRef ? scrollViewRef === null || scrollViewRef === void 0 ? void 0 : scrollViewRef.current : null,\n        rootMargin: '0px',\n        threshold: 0\n    });\n    const findIndexRecursive = (scrollPos, lowIndex, highIndex)=>{\n        if (lowIndex > highIndex) {\n            // We shouldn't get here - but no-op the index if we do.\n            return actualIndex;\n        }\n        const midpoint = Math.floor((lowIndex + highIndex) / 2);\n        const iBefore = Math.max(midpoint - 1, 0);\n        const iAfter = Math.min(midpoint + 1, childProgressiveSizes.current.length - 1);\n        const indexValue = childProgressiveSizes.current[midpoint];\n        const afterIndexValue = childProgressiveSizes.current[iAfter];\n        const beforeIndexValue = childProgressiveSizes.current[iBefore];\n        if (scrollPos <= afterIndexValue && scrollPos >= beforeIndexValue) {\n            /* We've found our index - if we are exactly matching before/after index that's ok,\n      better to reduce checks if it's right on the boundary. */ return midpoint;\n        }\n        if (indexValue > scrollPos) {\n            return findIndexRecursive(scrollPos, lowIndex, midpoint - 1);\n        } else {\n            return findIndexRecursive(scrollPos, midpoint + 1, highIndex);\n        }\n    };\n    const getIndexFromSizeArray = (scrollPos)=>{\n        /* Quick searches our progressive height array */ if (scrollPos === 0 || childProgressiveSizes.current.length === 0 || scrollPos <= childProgressiveSizes.current[0]) {\n            // Check start\n            return 0;\n        }\n        if (scrollPos >= childProgressiveSizes.current[childProgressiveSizes.current.length - 1]) {\n            // Check end\n            return childProgressiveSizes.current.length - 1;\n        }\n        return findIndexRecursive(scrollPos, 0, childProgressiveSizes.current.length - 1);\n    };\n    const getIndexFromScrollPosition = (scrollPos)=>{\n        if (!getItemSize) {\n            return Math.round(scrollPos / itemSize);\n        }\n        return getIndexFromSizeArray(scrollPos);\n    };\n    const calculateTotalSize = ()=>{\n        if (!getItemSize) {\n            return itemSize * numItems;\n        }\n        // Time for custom size calcs\n        return childProgressiveSizes.current[numItems - 1];\n    };\n    const calculateBefore = ()=>{\n        const currentIndex = Math.min(actualIndex, numItems);\n        if (!getItemSize) {\n            // The missing items from before virtualization starts height\n            return currentIndex * itemSize;\n        }\n        if (currentIndex <= 0) {\n            return 0;\n        }\n        // Time for custom size calcs\n        return childProgressiveSizes.current[currentIndex - 1];\n    };\n    const calculateAfter = ()=>{\n        if (numItems === 0) {\n            return 0;\n        }\n        const lastItemIndex = Math.min(actualIndex + virtualizerLength, numItems - 1);\n        if (!getItemSize) {\n            // The missing items from after virtualization ends height\n            const remainingItems = numItems - lastItemIndex - 1;\n            return remainingItems * itemSize;\n        }\n        // Time for custom size calcs\n        return childProgressiveSizes.current[numItems - 1] - childProgressiveSizes.current[lastItemIndex];\n    };\n    const updateChildRows = useCallback((newIndex)=>{\n        if (numItems === 0) {\n            /* Nothing to virtualize */ return [];\n        }\n        if (childArray.current.length !== numItems) {\n            childArray.current = new Array(virtualizerLength);\n        }\n        const _actualIndex = Math.max(newIndex, 0);\n        const end = Math.min(_actualIndex + virtualizerLength, numItems);\n        for(let i = _actualIndex; i < end; i++){\n            childArray.current[i - _actualIndex] = renderVirtualizerChildPlaceholder(renderChild(i), i);\n        }\n    }, [\n        numItems,\n        renderChild,\n        virtualizerLength\n    ]);\n    const setBeforeRef = useCallback((element)=>{\n        if (!element || beforeElementRef.current === element) {\n            return;\n        }\n        beforeElementRef.current = element;\n        const newList = [];\n        newList.push(beforeElementRef.current);\n        if (afterElementRef.current) {\n            newList.push(afterElementRef.current);\n        }\n        // Ensure we update array if before element changed\n        setObserverList(newList);\n    }, [\n        setObserverList\n    ]);\n    const setAfterRef = useCallback((element)=>{\n        if (!element || afterElementRef.current === element) {\n            return;\n        }\n        afterElementRef.current = element;\n        const newList = [];\n        if (beforeElementRef.current) {\n            newList.push(beforeElementRef.current);\n        }\n        newList.push(afterElementRef.current);\n        // Ensure we update array if after element changed\n        setObserverList(newList);\n    }, [\n        setObserverList\n    ]);\n    const updateCurrentItemSizes = (newIndex)=>{\n        if (!getItemSize) {\n            // Static sizes, not required.\n            return;\n        }\n        // We should always call our size function on index change (only for the items that will be rendered)\n        // This ensures we request the latest data for incoming items in case sizing has changed.\n        const endIndex = Math.min(newIndex + virtualizerLength, numItems);\n        const startIndex = Math.max(newIndex, 0);\n        let didUpdate = false;\n        for(let i = startIndex; i < endIndex; i++){\n            const newSize = getItemSize(i);\n            if (newSize !== childSizes.current[i]) {\n                childSizes.current[i] = newSize;\n                didUpdate = true;\n            }\n        }\n        if (didUpdate) {\n            // Update our progressive size array\n            for(let i = startIndex; i < numItems; i++){\n                const prevSize = i > 0 ? childProgressiveSizes.current[i - 1] : 0;\n                childProgressiveSizes.current[i] = prevSize + childSizes.current[i];\n            }\n        }\n    };\n    // Initialize the size array before first render.\n    const hasInitialized = useRef(false);\n    const initializeSizeArray = ()=>{\n        if (hasInitialized.current === false) {\n            hasInitialized.current = true;\n            populateSizeArrays();\n        }\n    };\n    // Initialization on mount - update array index to 0 (ready state).\n    // Only fire on mount (no deps).\n    useEffect(()=>{\n        if (actualIndex < 0) {\n            batchUpdateNewIndex(0);\n        }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    // If the user passes in an updated renderChild function - update current children\n    useEffect(()=>{\n        if (actualIndex >= 0) {\n            updateChildRows(actualIndex);\n            forceUpdate();\n        }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        renderChild,\n        updateChildRows\n    ]);\n    useEffect(()=>{\n        // Ensure we repopulate if getItemSize callback changes\n        populateSizeArrays();\n    // We only run this effect on getItemSize change (recalc dynamic sizes)\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        getItemSize\n    ]);\n    // Ensure we have run through and updated the whole size list array at least once.\n    initializeSizeArray();\n    if (getItemSize && (numItems !== childSizes.current.length || numItems !== childProgressiveSizes.current.length)) {\n        // Child length mismatch, repopulate size arrays.\n        populateSizeArrays();\n    }\n    // Ensure we recalc if virtualizer length changes\n    const maxCompare = Math.min(virtualizerLength, numItems);\n    if (childArray.current.length !== maxCompare && actualIndex + childArray.current.length < numItems) {\n        updateChildRows(actualIndex);\n    }\n    const isFullyInitialized = hasInitialized.current && actualIndex >= 0;\n    return {\n        components: {\n            before: 'div',\n            after: 'div',\n            beforeContainer: 'div',\n            afterContainer: 'div'\n        },\n        virtualizedChildren: childArray.current,\n        before: resolveShorthand(props.before, {\n            required: true,\n            defaultProps: {\n                ref: setBeforeRef,\n                role: 'none'\n            }\n        }),\n        after: resolveShorthand(props.after, {\n            required: true,\n            defaultProps: {\n                ref: setAfterRef,\n                role: 'none'\n            }\n        }),\n        beforeContainer: resolveShorthand(props.beforeContainer, {\n            required: true,\n            defaultProps: {\n                role: 'none'\n            }\n        }),\n        afterContainer: resolveShorthand(props.afterContainer, {\n            required: true,\n            defaultProps: {\n                role: 'none'\n            }\n        }),\n        beforeBufferHeight: isFullyInitialized ? calculateBefore() : 0,\n        afterBufferHeight: isFullyInitialized ? calculateAfter() : 0,\n        totalVirtualizerHeight: isFullyInitialized ? calculateTotalSize() : virtualizerLength * itemSize,\n        virtualizerStartIndex: actualIndex,\n        axis,\n        bufferSize,\n        reversed\n    };\n}\n"],"names":["useVirtualizer_unstable","props","itemSize","numItems","virtualizerLength","children","renderChild","getItemSize","bufferItems","Math","round","bufferSize","floor","scrollViewRef","axis","reversed","virtualizerContext","_virtualizerContext","useVirtualizerContextState_unstable","actualIndex","contextIndex","setActualIndex","setContextIndex","beforeElementRef","useRef","afterElementRef","childSizes","Array","childProgressiveSizes","childArray","forceUpdate","useReducer","horizontal","populateSizeArrays","current","length","index","batchUpdateNewIndex","updateChildRows","updateCurrentItemSizes","setObserverList","useIntersectionObserver","entries","observer","measurementPos","bufferCount","latestEntry","sort","entry1","entry2","time","find","entry","intersectionRatio","target","calculateAfter","calculateTotalSize","abs","boundingClientRect","bottom","top","right","left","calculateBefore","max","startIndex","getIndexFromScrollPosition","bufferedIndex","maxIndex","newStartIndex","min","flushSync","root","rootMargin","threshold","findIndexRecursive","scrollPos","lowIndex","highIndex","midpoint","iBefore","iAfter","indexValue","afterIndexValue","beforeIndexValue","getIndexFromSizeArray","currentIndex","lastItemIndex","remainingItems","useCallback","newIndex","_actualIndex","end","i","renderVirtualizerChildPlaceholder","setBeforeRef","element","newList","push","setAfterRef","endIndex","didUpdate","newSize","prevSize","hasInitialized","initializeSizeArray","useEffect","maxCompare","isFullyInitialized","components","before","after","beforeContainer","afterContainer","virtualizedChildren","resolveShorthand","required","defaultProps","ref","role","beforeBufferHeight","afterBufferHeight","totalVirtualizerHeight","virtualizerStartIndex"],"mappings":"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"}
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    createFlatTreeItems: ()=>createFlatTreeItems,
    flatTreeRootId: ()=>flatTreeRootId,
    VisibleFlatTreeItemGenerator: ()=>VisibleFlatTreeItemGenerator
});
const _interopRequireWildcard = require("@swc/helpers/lib/_interop_require_wildcard.js").default;
const _react = /*#__PURE__*/ _interopRequireWildcard(require("react"));
function createFlatTreeItems(flatTreeItemProps) {
    const root = createFlatTreeRootItem();
    const itemsPerValue = new Map([
        [
            root.value,
            root
        ]
    ]);
    const items = [];
    for(let index = 0; index < flatTreeItemProps.length; index++){
        const { parentValue =flatTreeRootId , ...treeItemProps } = flatTreeItemProps[index];
        const nextItemProps = flatTreeItemProps[index + 1];
        const currentParent = itemsPerValue.get(parentValue);
        if (!currentParent) {
            if (process.env.NODE_ENV === 'development') {
                // eslint-disable-next-line no-console
                console.error(`useFlatTree: item ${flatTreeItemProps[index].id} is wrongly positioned, did you properly ordered provided item props? make sure provided items are organized`);
            }
            break;
        }
        var _treeItemProps_itemType;
        const itemType = (_treeItemProps_itemType = treeItemProps.itemType) !== null && _treeItemProps_itemType !== void 0 ? _treeItemProps_itemType : treeItemProps.value === undefined || (nextItemProps === null || nextItemProps === void 0 ? void 0 : nextItemProps.parentValue) !== treeItemProps.value ? 'leaf' : 'branch';
        var _currentParent_level;
        const currentLevel = ((_currentParent_level = currentParent.level) !== null && _currentParent_level !== void 0 ? _currentParent_level : 0) + 1;
        const currentChildrenSize = ++currentParent.childrenSize;
        const ref = /*#__PURE__*/ _react.createRef();
        const flatTreeItem = {
            value: treeItemProps.value,
            getTreeItemProps: ()=>({
                    ...treeItemProps,
                    'aria-level': currentLevel,
                    'aria-posinset': currentChildrenSize,
                    'aria-setsize': currentParent.childrenSize,
                    itemType,
                    // a reference to every parent element is necessary to ensure navigation
                    ref: flatTreeItem.childrenSize > 0 ? ref : undefined
                }),
            ref,
            level: currentLevel,
            parentValue,
            childrenSize: 0,
            index: -1
        };
        itemsPerValue.set(flatTreeItem.value, flatTreeItem);
        items.push(flatTreeItem);
    }
    const flatTreeItems = {
        root,
        size: items.length,
        getByIndex: (index)=>items[index],
        get: (key)=>itemsPerValue.get(key),
        set: (key, value)=>itemsPerValue.set(key, value)
    };
    return flatTreeItems;
}
const flatTreeRootId = '__fuiFlatTreeRoot';
function createFlatTreeRootItem() {
    return {
        ref: {
            current: null
        },
        value: flatTreeRootId,
        parentValue: undefined,
        getTreeItemProps: ()=>{
            if (process.env.NODE_ENV !== 'production') {
                // eslint-disable-next-line no-console
                console.error('useFlatTree: internal error, trying to access treeitem props from invalid root element');
            }
            return {
                value: flatTreeRootId,
                'aria-setsize': -1,
                'aria-level': -1,
                'aria-posinset': -1,
                itemType: 'branch'
            };
        },
        childrenSize: 0,
        get index () {
            if (process.env.NODE_ENV !== 'production') {
                // eslint-disable-next-line no-console
                console.error('useFlatTree: internal error, trying to access treeitem props from invalid root element');
            }
            return -1;
        },
        level: 0
    };
}
function* VisibleFlatTreeItemGenerator(openItems, flatTreeItems) {
    for(let index = 0, visibleIndex = 0; index < flatTreeItems.size; index++){
        const item = flatTreeItems.getByIndex(index);
        if (isItemVisible(item, openItems, flatTreeItems)) {
            item.index = visibleIndex++;
            yield item;
        } else {
            // Jump the amount of children the current item has, since those items will also be hidden
            index += item.childrenSize;
        }
    }
}
function isItemVisible(item, openItems, flatTreeItems) {
    if (item.level === 1) {
        return true;
    }
    while(item.parentValue && item.parentValue !== flatTreeItems.root.value){
        if (!openItems.has(item.parentValue)) {
            return false;
        }
        const parent = flatTreeItems.get(item.parentValue);
        if (!parent) {
            return false;
        }
        item = parent;
    }
    return true;
}

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useTreeItem_unstable", {
    enumerable: true,
    get: ()=>useTreeItem_unstable
});
const _interopRequireWildcard = require("@swc/helpers/lib/_interop_require_wildcard.js").default;
const _react = /*#__PURE__*/ _interopRequireWildcard(require("react"));
const _reactUtilities = require("@fluentui/react-utilities");
const _reactPortal = require("@fluentui/react-portal");
const _index = require("../../contexts/index");
const _tokens = require("../../utils/tokens");
function useTreeItem_unstable(props, ref) {
    const contextLevel = (0, _index.useTreeContext_unstable)((ctx)=>ctx.level);
    const id = (0, _reactUtilities.useId)('fui-TreeItem-', props.id);
    const { onClick , onKeyDown , as ='div' , value =id , itemType ='leaf' , 'aria-level': level = contextLevel , ...rest } = props;
    const requestTreeResponse = (0, _index.useTreeContext_unstable)((ctx)=>ctx.requestTreeResponse);
    const [isActionsVisible, setActionsVisible] = _react.useState(false);
    const [isAsideVisible, setAsideVisible] = _react.useState(true);
    const handleActionsRef = (actions)=>{
        setAsideVisible(actions === null);
    };
    const open = (0, _index.useTreeContext_unstable)((ctx)=>ctx.openItems.has(value));
    const actionsRef = _react.useRef(null);
    const expandIconRef = _react.useRef(null);
    const layoutRef = _react.useRef(null);
    const subtreeRef = _react.useRef(null);
    const handleClick = (0, _reactUtilities.useEventCallback)((event)=>{
        onClick === null || onClick === void 0 ? void 0 : onClick(event);
        if (event.isDefaultPrevented()) {
            return;
        }
        const isEventFromActions = actionsRef.current && (0, _reactPortal.elementContains)(actionsRef.current, event.target);
        if (isEventFromActions) {
            return;
        }
        const isEventFromSubtree = subtreeRef.current && (0, _reactPortal.elementContains)(subtreeRef.current, event.target);
        if (isEventFromSubtree) {
            return;
        }
        const isFromExpandIcon = expandIconRef.current && (0, _reactPortal.elementContains)(expandIconRef.current, event.target);
        requestTreeResponse({
            event,
            itemType,
            value,
            type: isFromExpandIcon ? _tokens.treeDataTypes.ExpandIconClick : _tokens.treeDataTypes.Click
        });
    });
    const handleKeyDown = (0, _reactUtilities.useEventCallback)((event)=>{
        onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown(event);
        if (event.isDefaultPrevented()) {
            return;
        }
        if (event.currentTarget !== event.target) {
            return;
        }
        switch(event.key){
            case _tokens.treeDataTypes.End:
            case _tokens.treeDataTypes.Home:
            case _tokens.treeDataTypes.Enter:
            case _tokens.treeDataTypes.ArrowUp:
            case _tokens.treeDataTypes.ArrowDown:
            case _tokens.treeDataTypes.ArrowLeft:
            case _tokens.treeDataTypes.ArrowRight:
                return requestTreeResponse({
                    event,
                    itemType,
                    value,
                    type: event.key
                });
        }
        const isTypeAheadCharacter = event.key.length === 1 && event.key.match(/\w/) && !event.altKey && !event.ctrlKey && !event.metaKey;
        if (isTypeAheadCharacter) {
            requestTreeResponse({
                event,
                itemType,
                value,
                type: _tokens.treeDataTypes.TypeAhead
            });
        }
    });
    const handleActionsVisible = (0, _reactUtilities.useEventCallback)((event)=>{
        const isTargetFromSubtree = Boolean(subtreeRef.current && (0, _reactPortal.elementContains)(subtreeRef.current, event.target));
        if (!isTargetFromSubtree) {
            setActionsVisible(true);
        }
    });
    const handleActionsInvisible = (0, _reactUtilities.useEventCallback)((event)=>{
        const isTargetFromSubtree = Boolean(subtreeRef.current && (0, _reactPortal.elementContains)(subtreeRef.current, event.target));
        const isRelatedTargetFromActions = Boolean(actionsRef.current && (0, _reactPortal.elementContains)(actionsRef.current, event.relatedTarget));
        if (isRelatedTargetFromActions) {
            return setActionsVisible(true);
        }
        if (!isTargetFromSubtree) {
            return setActionsVisible(false);
        }
    });
    return {
        value,
        open,
        subtreeRef,
        actionsRef: (0, _reactUtilities.useMergedRefs)(actionsRef, handleActionsRef),
        expandIconRef,
        layoutRef,
        itemType,
        isActionsVisible,
        isAsideVisible,
        level,
        components: {
            root: 'div'
        },
        root: (0, _reactUtilities.getNativeElementProps)(as, {
            tabIndex: -1,
            ...rest,
            id,
            ref,
            'aria-level': level,
            'aria-expanded': itemType === 'branch' ? open : undefined,
            role: 'treeitem',
            onClick: handleClick,
            onKeyDown: handleKeyDown,
            onMouseOver: handleActionsVisible,
            onFocus: handleActionsVisible,
            onMouseOut: handleActionsInvisible,
            onBlur: handleActionsInvisible
        })
    };
}

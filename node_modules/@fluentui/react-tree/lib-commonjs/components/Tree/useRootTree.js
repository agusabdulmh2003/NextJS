"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useRootTree", {
    enumerable: true,
    get: ()=>useRootTree
});
const _interopRequireWildcard = require("@swc/helpers/lib/_interop_require_wildcard.js").default;
const _react = /*#__PURE__*/ _interopRequireWildcard(require("react"));
const _reactDom = /*#__PURE__*/ _interopRequireWildcard(require("react-dom"));
const _reactUtilities = require("@fluentui/react-utilities");
const _hooks = require("../../hooks");
const _tokens = require("../../utils/tokens");
function useRootTree(props, ref) {
    warnIfNoProperPropsRootTree(props);
    const { appearance ='subtle' , size ='medium'  } = props;
    const [openItems, updateOpenItems] = (0, _hooks.useOpenItemsState)(props);
    const [navigate, navigationRef] = (0, _hooks.useNestedTreeNavigation)();
    const requestOpenChange = (data)=>{
        var _props_onOpenChange;
        (_props_onOpenChange = props.onOpenChange) === null || _props_onOpenChange === void 0 ? void 0 : _props_onOpenChange.call(props, data.event, data);
        if (data.event.isDefaultPrevented()) {
            return;
        }
        return updateOpenItems(data);
    };
    const requestNavigation = (data)=>{
        var _props_onNavigation_unstable;
        (_props_onNavigation_unstable = props.onNavigation_unstable) === null || _props_onNavigation_unstable === void 0 ? void 0 : _props_onNavigation_unstable.call(props, data.event, data);
        if (data.event.isDefaultPrevented()) {
            return;
        }
        navigate(data);
        if (data.type === _tokens.treeDataTypes.ArrowDown || data.type === _tokens.treeDataTypes.ArrowUp) {
            data.event.preventDefault();
        }
    };
    const handleTreeItemClick = ({ event , value , itemType , type  })=>{
        _reactDom.unstable_batchedUpdates(()=>{
            requestOpenChange({
                event,
                value,
                open: itemType === 'branch' && !openItems.has(value),
                type,
                target: event.currentTarget
            });
            requestNavigation({
                event,
                value,
                target: event.currentTarget,
                type: _tokens.treeDataTypes.Click
            });
        });
    };
    const handleTreeItemKeyDown = ({ event , value , type , itemType  })=>{
        const open = openItems.has(value);
        switch(type){
            case _tokens.treeDataTypes.ArrowRight:
                if (itemType === 'leaf') {
                    return;
                }
                if (!open) {
                    return requestOpenChange({
                        event,
                        value,
                        open: true,
                        type: _tokens.treeDataTypes.ArrowRight,
                        target: event.currentTarget
                    });
                }
                return requestNavigation({
                    event,
                    value,
                    type,
                    target: event.currentTarget
                });
            case _tokens.treeDataTypes.Enter:
                return requestOpenChange({
                    event,
                    value,
                    open: itemType === 'branch' && !open,
                    type: _tokens.treeDataTypes.Enter,
                    target: event.currentTarget
                });
            case _tokens.treeDataTypes.ArrowLeft:
                if (open && itemType === 'branch') {
                    return requestOpenChange({
                        event,
                        value,
                        open: false,
                        type: _tokens.treeDataTypes.ArrowLeft,
                        target: event.currentTarget
                    });
                }
                return requestNavigation({
                    event,
                    value,
                    target: event.currentTarget,
                    type: _tokens.treeDataTypes.ArrowLeft
                });
            case _tokens.treeDataTypes.End:
            case _tokens.treeDataTypes.Home:
            case _tokens.treeDataTypes.ArrowUp:
            case _tokens.treeDataTypes.ArrowDown:
            case _tokens.treeDataTypes.TypeAhead:
                return requestNavigation({
                    event,
                    value,
                    type,
                    target: event.currentTarget
                });
        }
    };
    const requestTreeResponse = (0, _reactUtilities.useEventCallback)((request)=>{
        switch(request.event.type){
            case 'click':
                // casting is required here as we're narrowing down the event to only click events
                return handleTreeItemClick(request);
            case 'keydown':
                // casting is required here as we're narrowing down the event to only keyboard events
                return handleTreeItemKeyDown(request);
        }
    });
    return {
        components: {
            root: 'div'
        },
        open: true,
        appearance,
        size,
        level: 1,
        openItems,
        requestTreeResponse,
        root: (0, _reactUtilities.getNativeElementProps)('div', {
            ref: (0, _reactUtilities.useMergedRefs)(navigationRef, ref),
            role: 'tree',
            ...props
        })
    };
}
function warnIfNoProperPropsRootTree(props) {
    if (process.env.NODE_ENV === 'development') {
        if (!props['aria-label'] && !props['aria-labelledby']) {
            // eslint-disable-next-line no-console
            console.warn('Tree must have either a `aria-label` or `aria-labelledby` property defined');
        }
    }
}

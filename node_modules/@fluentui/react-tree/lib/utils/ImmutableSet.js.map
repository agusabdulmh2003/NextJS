{"version":3,"sources":["ImmutableSet.ts"],"sourcesContent":["export interface ImmutableSet<Value> {\n  /**\n   * The number of (unique) elements in a ImmutableSet.\n   */\n  readonly size: number;\n  /**\n   * Creates a new ImmutableSet containing all previous element plus the one provided as argument\n   * @param value - new value to be included in the new ImmutableSet instance\n   */\n  add(value: Value): ImmutableSet<Value>;\n  /**\n   * Returns a reference to ImmutableSet.emptySet\n   */\n  clear(): ImmutableSet<Value>;\n  /**\n   * Creates a new ImmutableSet with the original items and removes a specified value from the new ImmutableSet.\n   */\n  delete(value: Value): ImmutableSet<Value>;\n  /**\n   * @returns a boolean indicating whether an element with the specified value exists in the ImmutableSet or not.\n   */\n  has(value: Value): boolean;\n  /** Iterates over values in the ImmutableSet. */\n  [Symbol.iterator](): IterableIterator<Value>;\n}\n\nexport const emptyImmutableSet = createImmutableSet<never>();\n\n/**\n * properly creates an ImmutableSet instance from an iterable\n */\nexport function createImmutableSet<Value>(iterable?: Iterable<Value>): ImmutableSet<Value> {\n  const internalSet = new Set(iterable);\n  return dangerouslyCreateImmutableSet(internalSet);\n}\n/**\n * Avoid using *dangerouslyCreateImmutableSet*, since this method will expose internally used set, use  createImmutableSet instead,\n * @param internalSet - a set that is used internally to store values.\n */\nexport function dangerouslyCreateImmutableSet<Value>(internalSet: Set<Value>): ImmutableSet<Value> {\n  return {\n    size: internalSet.size,\n    add(value) {\n      const nextSet = new Set(internalSet);\n      nextSet.add(value);\n      return dangerouslyCreateImmutableSet(nextSet);\n    },\n    clear() {\n      return emptyImmutableSet;\n    },\n    delete(value) {\n      const nextSet = new Set(internalSet);\n      nextSet.delete(value);\n      return dangerouslyCreateImmutableSet(nextSet);\n    },\n    has(value) {\n      return internalSet.has(value);\n    },\n    [Symbol.iterator]() {\n      return internalSet[Symbol.iterator]();\n    },\n  };\n}\n"],"names":["emptyImmutableSet","createImmutableSet","iterable","internalSet","Set","dangerouslyCreateImmutableSet","size","add","value","nextSet","clear","delete","has","Symbol","iterator"],"mappings":"AA0BA,OAAO,MAAMA,oBAAoBC,qBAA4B;AAE7D;;CAEC,GACD,OAAO,SAASA,mBAA0BC,QAA0B,EAAuB;IACzF,MAAMC,cAAc,IAAIC,IAAIF;IAC5B,OAAOG,8BAA8BF;AACvC,CAAC;AACD;;;CAGC,GACD,OAAO,SAASE,8BAAqCF,WAAuB,EAAuB;IACjG,OAAO;QACLG,MAAMH,YAAYG,IAAI;QACtBC,KAAIC,KAAK,EAAE;YACT,MAAMC,UAAU,IAAIL,IAAID;YACxBM,QAAQF,GAAG,CAACC;YACZ,OAAOH,8BAA8BI;QACvC;QACAC,SAAQ;YACN,OAAOV;QACT;QACAW,QAAOH,KAAK,EAAE;YACZ,MAAMC,UAAU,IAAIL,IAAID;YACxBM,QAAQE,MAAM,CAACH;YACf,OAAOH,8BAA8BI;QACvC;QACAG,KAAIJ,KAAK,EAAE;YACT,OAAOL,YAAYS,GAAG,CAACJ;QACzB;QACA,CAACK,OAAOC,QAAQ,CAAC,IAAG;YAClB,OAAOX,WAAW,CAACU,OAAOC,QAAQ,CAAC;QACrC;IACF;AACF,CAAC"}
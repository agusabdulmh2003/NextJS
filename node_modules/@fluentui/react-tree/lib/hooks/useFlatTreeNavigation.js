import { useFluent_unstable } from '@fluentui/react-shared-contexts';
import { useEventCallback, useMergedRefs } from '@fluentui/react-utilities';
import { nextTypeAheadElement } from '../utils/nextTypeAheadElement';
import { treeDataTypes } from '../utils/tokens';
import { treeItemFilter } from '../utils/treeItemFilter';
import { useHTMLElementWalkerRef } from './useHTMLElementWalker';
import { useRovingTabIndex } from './useRovingTabIndexes';
export function useFlatTreeNavigation(flatTreeItems) {
    const { targetDocument  } = useFluent_unstable();
    const [treeItemWalkerRef, treeItemWalkerRootRef] = useHTMLElementWalkerRef(treeItemFilter);
    const [{ rove  }, rovingRootRef] = useRovingTabIndex(treeItemFilter);
    function getNextElement(data) {
        if (!targetDocument || !treeItemWalkerRef.current) {
            return null;
        }
        const treeItemWalker = treeItemWalkerRef.current;
        switch(data.type){
            case treeDataTypes.Click:
                return data.target;
            case treeDataTypes.TypeAhead:
                treeItemWalker.currentElement = data.target;
                return nextTypeAheadElement(treeItemWalker, data.event.key);
            case treeDataTypes.ArrowLeft:
                return parentElement(flatTreeItems, data.value);
            case treeDataTypes.ArrowRight:
                treeItemWalker.currentElement = data.target;
                return firstChild(data.target, treeItemWalker);
            case treeDataTypes.End:
                treeItemWalker.currentElement = treeItemWalker.root;
                return treeItemWalker.lastChild();
            case treeDataTypes.Home:
                treeItemWalker.currentElement = treeItemWalker.root;
                return treeItemWalker.firstChild();
            case treeDataTypes.ArrowDown:
                treeItemWalker.currentElement = data.target;
                return treeItemWalker.nextElement();
            case treeDataTypes.ArrowUp:
                treeItemWalker.currentElement = data.target;
                return treeItemWalker.previousElement();
        }
    }
    const navigate = useEventCallback((data)=>{
        const nextElement = getNextElement(data);
        if (nextElement) {
            rove(nextElement);
        }
    });
    return [
        navigate,
        useMergedRefs(treeItemWalkerRootRef, rovingRootRef)
    ];
}
function firstChild(target, treeWalker) {
    const nextElement = treeWalker.nextElement();
    if (!nextElement) {
        return null;
    }
    const nextElementAriaPosInSet = nextElement.getAttribute('aria-posinset');
    const nextElementAriaLevel = nextElement.getAttribute('aria-level');
    const targetAriaLevel = target.getAttribute('aria-level');
    if (nextElementAriaPosInSet === '1' && Number(nextElementAriaLevel) === Number(targetAriaLevel) + 1) {
        return nextElement;
    }
    return null;
}
function parentElement(flatTreeItems, value) {
    const flatTreeItem = flatTreeItems.get(value);
    if (flatTreeItem === null || flatTreeItem === void 0 ? void 0 : flatTreeItem.parentValue) {
        const parentItem = flatTreeItems.get(flatTreeItem.parentValue);
        var _parentItem_ref_current;
        return (_parentItem_ref_current = parentItem === null || parentItem === void 0 ? void 0 : parentItem.ref.current) !== null && _parentItem_ref_current !== void 0 ? _parentItem_ref_current : null;
    }
    return null;
}

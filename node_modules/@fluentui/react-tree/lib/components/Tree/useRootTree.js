import * as React from 'react';
import * as ReactDOM from 'react-dom';
import { getNativeElementProps, useEventCallback, useMergedRefs } from '@fluentui/react-utilities';
import { useNestedTreeNavigation, useOpenItemsState } from '../../hooks';
import { treeDataTypes } from '../../utils/tokens';
/**
 * Create the state required to render the root level Tree.
 *
 * @param props - props from this instance of Tree
 * @param ref - reference to root HTMLElement of Tree
 */ export function useRootTree(props, ref) {
    warnIfNoProperPropsRootTree(props);
    const { appearance ='subtle' , size ='medium'  } = props;
    const [openItems, updateOpenItems] = useOpenItemsState(props);
    const [navigate, navigationRef] = useNestedTreeNavigation();
    const requestOpenChange = (data)=>{
        var _props_onOpenChange;
        (_props_onOpenChange = props.onOpenChange) === null || _props_onOpenChange === void 0 ? void 0 : _props_onOpenChange.call(props, data.event, data);
        if (data.event.isDefaultPrevented()) {
            return;
        }
        return updateOpenItems(data);
    };
    const requestNavigation = (data)=>{
        var _props_onNavigation_unstable;
        (_props_onNavigation_unstable = props.onNavigation_unstable) === null || _props_onNavigation_unstable === void 0 ? void 0 : _props_onNavigation_unstable.call(props, data.event, data);
        if (data.event.isDefaultPrevented()) {
            return;
        }
        navigate(data);
        if (data.type === treeDataTypes.ArrowDown || data.type === treeDataTypes.ArrowUp) {
            data.event.preventDefault();
        }
    };
    const handleTreeItemClick = ({ event , value , itemType , type  })=>{
        ReactDOM.unstable_batchedUpdates(()=>{
            requestOpenChange({
                event,
                value,
                open: itemType === 'branch' && !openItems.has(value),
                type,
                target: event.currentTarget
            });
            requestNavigation({
                event,
                value,
                target: event.currentTarget,
                type: treeDataTypes.Click
            });
        });
    };
    const handleTreeItemKeyDown = ({ event , value , type , itemType  })=>{
        const open = openItems.has(value);
        switch(type){
            case treeDataTypes.ArrowRight:
                if (itemType === 'leaf') {
                    return;
                }
                if (!open) {
                    return requestOpenChange({
                        event,
                        value,
                        open: true,
                        type: treeDataTypes.ArrowRight,
                        target: event.currentTarget
                    });
                }
                return requestNavigation({
                    event,
                    value,
                    type,
                    target: event.currentTarget
                });
            case treeDataTypes.Enter:
                return requestOpenChange({
                    event,
                    value,
                    open: itemType === 'branch' && !open,
                    type: treeDataTypes.Enter,
                    target: event.currentTarget
                });
            case treeDataTypes.ArrowLeft:
                if (open && itemType === 'branch') {
                    return requestOpenChange({
                        event,
                        value,
                        open: false,
                        type: treeDataTypes.ArrowLeft,
                        target: event.currentTarget
                    });
                }
                return requestNavigation({
                    event,
                    value,
                    target: event.currentTarget,
                    type: treeDataTypes.ArrowLeft
                });
            case treeDataTypes.End:
            case treeDataTypes.Home:
            case treeDataTypes.ArrowUp:
            case treeDataTypes.ArrowDown:
            case treeDataTypes.TypeAhead:
                return requestNavigation({
                    event,
                    value,
                    type,
                    target: event.currentTarget
                });
        }
    };
    const requestTreeResponse = useEventCallback((request)=>{
        switch(request.event.type){
            case 'click':
                // casting is required here as we're narrowing down the event to only click events
                return handleTreeItemClick(request);
            case 'keydown':
                // casting is required here as we're narrowing down the event to only keyboard events
                return handleTreeItemKeyDown(request);
        }
    });
    return {
        components: {
            root: 'div'
        },
        open: true,
        appearance,
        size,
        level: 1,
        openItems,
        requestTreeResponse,
        root: getNativeElementProps('div', {
            ref: useMergedRefs(navigationRef, ref),
            role: 'tree',
            ...props
        })
    };
}
function warnIfNoProperPropsRootTree(props) {
    if (process.env.NODE_ENV === 'development') {
        if (!props['aria-label'] && !props['aria-labelledby']) {
            // eslint-disable-next-line no-console
            console.warn('Tree must have either a `aria-label` or `aria-labelledby` property defined');
        }
    }
}

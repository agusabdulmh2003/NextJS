/// <reference types="react" />

import { ArrowDown } from '@fluentui/keyboard-keys';
import { ArrowLeft } from '@fluentui/keyboard-keys';
import { ArrowRight } from '@fluentui/keyboard-keys';
import { ArrowUp } from '@fluentui/keyboard-keys';
import type { AvatarContextValue } from '@fluentui/react-avatar';
import type { AvatarSize } from '@fluentui/react-avatar';
import { ButtonContextValue } from '@fluentui/react-button';
import type { ComponentProps } from '@fluentui/react-utilities';
import type { ComponentState } from '@fluentui/react-utilities';
import { ContextSelector } from '@fluentui/react-context-selector';
import { End } from '@fluentui/keyboard-keys';
import { Enter } from '@fluentui/keyboard-keys';
import type { ExtractSlotProps } from '@fluentui/react-utilities';
import { FC } from 'react';
import type { ForwardRefComponent } from '@fluentui/react-utilities';
import { Home } from '@fluentui/keyboard-keys';
import { Provider } from 'react';
import { ProviderProps } from 'react';
import * as React_2 from 'react';
import type { Slot } from '@fluentui/react-utilities';
import type { SlotClassNames } from '@fluentui/react-utilities';
import { SlotRenderFunction } from '@fluentui/react-utilities';

declare type FlattenedTreeItem<Props extends TreeItemProps<unknown>> = FlatTreeItemProps<NonNullable<Props['value']>> & Props;

/**
 * Converts a nested structure to a flat one which can be consumed by `useFlatTreeItems`
 * @example
 * ```tsx
 * const defaultItems = flattenTree_unstable([
 *  {
 *    children: <TreeItemLayout>level 1, item 1</TreeItemLayout>,
 *    subtree: [
 *      {
 *        children: <TreeItemLayout>level 2, item 1</TreeItemLayout>,
 *      },
 *      {
 *        children: <TreeItemLayout>level 2, item 2</TreeItemLayout>,
 *      },
 *      {
 *        children: <TreeItemLayout>level 2, item 3</TreeItemLayout>,
 *      },
 *    ],
 *  },
 *  {
 *    children: <TreeItemLayout>level 1, item 2</TreeItemLayout>,
 *    subtree: [
 *      {
 *        children: <TreeItemLayout>level 2, item 1</TreeItemLayout>,
 *        subtree: [
 *          {
 *            children: <TreeItemLayout>level 3, item 1</TreeItemLayout>,
 *            subtree: [
 *              {
 *                children: <TreeItemLayout>level 4, item 1</TreeItemLayout>,
 *              },
 *            ],
 *          },
 *        ],
 *      },
 *    ],
 *  },
 * ]);
 * ```
 */
export declare const flattenTree_unstable: <Props extends TreeItemProps<unknown>>(items: NestedTreeItem<Props>[]) => FlattenedTreeItem<Props>[];

/**
 * FlatTree API to manage all required mechanisms to convert a list of items into renderable TreeItems
 * in multiple scenarios including virtualization.
 *
 * !!A flat tree is an unofficial spec for tree!!
 *
 * It should be used on cases where more complex interactions with a Tree is required.
 *
 * On simple scenarios it is advised to simply use a nested structure instead.
 */
export declare type FlatTree<Props extends FlatTreeItemProps<unknown> = FlatTreeItemProps> = {
    /**
     * returns the properties required for the Tree component to work properly.
     * That includes:
     * `openItems`, `onOpenChange`, `onNavigation_unstable` and `ref`
     */
    getTreeProps(): FlatTreeProps<Props['value']>;
    /**
     * internal method used to react to an `onNavigation` event.
     * This method ensures proper navigation on keyboard and mouse interaction.
     * In case of virtualization it might be required to cancel default provided `onNavigation`
     * event and then call this method manually.
     *
     * @example
     * ```ts
     * // react-window
     * const handleNavigation = (event, data) => {
     *   event.preventDefault();
     *   const nextItem = tree.getNextNavigableItem(data);
     *   // scroll to item using virtualization scroll mechanism
     *   if (nextItem && document.getElementById(nextItem.id)) {
     *     listRef.current.scrollToItem(nextItem.index);
     *   }
     *   // wait for scrolling to happen and then invoke navigate method
     *   requestAnimationFrame(() => {
     *     tree.navigate(data);
     *   });
     * };
     *```
     */
    navigate(data: TreeNavigationData_unstable<Props['value']>): void;
    /**
     * returns next item to be focused on a navigation.
     * This method is provided to decouple the element that needs to be focused from
     *  the action of focusing it itself.
     *
     * On the case of TypeAhead navigation this method returns the current item.
     */
    getNextNavigableItem(visibleItems: FlatTreeItem<Props>[], data: TreeNavigationData_unstable<Props['value']>): FlatTreeItem<Props> | undefined;
    /**
     * an iterable containing all visually available flat tree items
     */
    items(): IterableIterator<FlatTreeItem<Props>>;
};

/**
 * The item that is returned by `useFlatTree`, it represents a wrapper around the properties provided to
 * `useFlatTree` but with extra information that might be useful on flat tree scenarios
 */
export declare type FlatTreeItem<Props extends FlatTreeItemProps<unknown> = FlatTreeItemProps> = {
    index: number;
    level: number;
    childrenSize: number;
    value: Props['value'];
    parentValue: Props['parentValue'];
    /**
     * A reference to the element that will render the `TreeItem`,
     * this is necessary for nodes with parents (to ensure child to parent navigation),
     * if a node has no parent then this reference will be null.
     */
    ref: React_2.RefObject<HTMLDivElement>;
    getTreeItemProps(): Required<Pick<Props, 'value' | 'aria-setsize' | 'aria-level' | 'aria-posinset' | 'itemType'>> & Omit<Props, 'parentValue'>;
};

export declare type FlatTreeItemProps<Value = string> = Omit<TreeItemProps<Value>, 'itemType'> & Partial<Pick<TreeItemProps<Value>, 'itemType'>> & {
    value: Value;
    parentValue?: Value;
};

declare type FlatTreeOptions<Props extends FlatTreeItemProps<unknown> = FlatTreeItemProps> = Pick<TreeProps<Props['value']>, 'openItems' | 'defaultOpenItems' | 'onOpenChange' | 'onNavigation_unstable'>;

export declare type FlatTreeProps<Value = string> = Required<Pick<TreeProps<Value>, 'openItems' | 'onOpenChange' | 'onNavigation_unstable'>> & {
    ref: React_2.Ref<HTMLDivElement>;
    openItems: ImmutableSet<Value>;
};

declare interface ImmutableSet<Value> {
    /**
     * The number of (unique) elements in a ImmutableSet.
     */
    readonly size: number;
    /**
     * Creates a new ImmutableSet containing all previous element plus the one provided as argument
     * @param value - new value to be included in the new ImmutableSet instance
     */
    add(value: Value): ImmutableSet<Value>;
    /**
     * Returns a reference to ImmutableSet.emptySet
     */
    clear(): ImmutableSet<Value>;
    /**
     * Creates a new ImmutableSet with the original items and removes a specified value from the new ImmutableSet.
     */
    delete(value: Value): ImmutableSet<Value>;
    /**
     * @returns a boolean indicating whether an element with the specified value exists in the ImmutableSet or not.
     */
    has(value: Value): boolean;
    /** Iterates over values in the ImmutableSet. */
    [Symbol.iterator](): IterableIterator<Value>;
}

export declare type NestedTreeItem<Props extends TreeItemProps<unknown>> = Omit<Props, 'subtree' | 'itemType'> & {
    subtree?: NestedTreeItem<Props>[];
};

declare type OmitWithoutExpanding<P, K extends string | number | symbol> = P extends unknown ? Omit<P, K> : P;

export declare const renderTree_unstable: (state: TreeState, contextValues: TreeContextValues) => JSX.Element;

/**
 * Render the final JSX of TreeItem
 */
export declare const renderTreeItem_unstable: (state: TreeItemState, contextValues: TreeItemContextValues) => JSX.Element;

/**
 * Render the final JSX of TreeItemAside
 */
export declare const renderTreeItemAside_unstable: (state: TreeItemAsideState) => JSX.Element | null;

/**
 * Render the final JSX of TreeItemLayout
 */
export declare const renderTreeItemLayout_unstable: (state: TreeItemLayoutState) => JSX.Element;

/**
 * Render the final JSX of TreeItemPersonaLayout
 */
export declare const renderTreeItemPersonaLayout_unstable: (state: TreeItemPersonaLayoutState, contextValues: TreeItemPersonaLayoutContextValues) => JSX.Element;

/**
 * A tree view widget presents a hierarchical list.
 * Any item in the hierarchy may have child items,
 * and items that have children may be expanded or collapsed to show or hide the children.
 * For example, in a file system navigator that uses a tree view to display folders and files,
 * an item representing a folder can be expanded to reveal the contents of the folder,
 * which may be files, folders, or both.
 */
export declare const Tree: React_2.ForwardRefExoticComponent<Omit<TreeSlots, "root"> & Omit<{
    as?: "div" | undefined;
} & Pick<React_2.DetailedHTMLProps<React_2.HTMLAttributes<HTMLDivElement>, HTMLDivElement>, "key" | keyof React_2.HTMLAttributes<HTMLDivElement>> & {
    ref?: ((instance: HTMLDivElement | null) => void) | React_2.RefObject<HTMLDivElement> | null | undefined;
} & {
    children?: React_2.ReactNode | SlotRenderFunction<Pick<React_2.DetailedHTMLProps<React_2.HTMLAttributes<HTMLDivElement>, HTMLDivElement>, "key" | keyof React_2.HTMLAttributes<HTMLDivElement>> & {
    ref?: ((instance: HTMLDivElement | null) => void) | React_2.RefObject<HTMLDivElement> | null | undefined;
    }>;
}, "ref"> & {
    appearance?: "transparent" | "subtle" | "subtle-alpha" | undefined;
    size?: "small" | "medium" | undefined;
    openItems?: Iterable<string> | undefined;
    defaultOpenItems?: Iterable<string> | undefined;
    onOpenChange?(event: React_2.KeyboardEvent<HTMLElement> | React_2.MouseEvent<HTMLElement, MouseEvent>, data: TreeOpenChangeData<string>): void;
    onNavigation_unstable?(event: React_2.KeyboardEvent<HTMLElement> | React_2.MouseEvent<HTMLElement, MouseEvent>, data: TreeNavigationData_unstable<string>): void;
} & React_2.RefAttributes<HTMLDivElement>> & (<Value = string>(props: TreeProps<Value>) => JSX.Element);

export declare const treeClassNames: SlotClassNames<TreeSlots>;

export declare type TreeContextValue = {
    level: number;
    appearance: 'subtle' | 'subtle-alpha' | 'transparent';
    size: 'small' | 'medium';
    openItems: ImmutableSet<unknown>;
    /**
     * requests root Tree component to respond to some tree item event,
     */
    requestTreeResponse(request: TreeItemRequest<unknown>): void;
};

declare type TreeContextValues = {
    tree: TreeContextValue;
};

/**
 * The `TreeItem` component represents a single item in a tree.
 * It expects a certain order of children to work properly: the first child should be the node itself,
 * and the second child should be a nested subtree in the form of another Tree component or a standalone TreeItem.
 * This order follows the same order as document traversal for the TreeWalker API in JavaScript:
 * https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker.
 * The content and layout of a TreeItem can be defined using the TreeItemLayout or TreeItemPersonaLayout component,
 * which should be used as a direct child of TreeItem.
 *
 * When a TreeItem has nested child subtree, an expand/collapse control is displayed,
 * allowing the user to show or hide the children.
 */
export declare const TreeItem: React_2.ForwardRefExoticComponent<Omit<Partial<TreeItemSlots>, "root"> & Omit<{
    as?: "div" | undefined;
} & Pick<React_2.DetailedHTMLProps<React_2.HTMLAttributes<HTMLDivElement>, HTMLDivElement>, "key" | keyof React_2.HTMLAttributes<HTMLDivElement>> & {
    ref?: ((instance: HTMLDivElement | null) => void) | React_2.RefObject<HTMLDivElement> | null | undefined;
} & {
    children?: React_2.ReactNode | SlotRenderFunction<Pick<React_2.DetailedHTMLProps<React_2.HTMLAttributes<HTMLDivElement>, HTMLDivElement>, "key" | keyof React_2.HTMLAttributes<HTMLDivElement>> & {
    ref?: ((instance: HTMLDivElement | null) => void) | React_2.RefObject<HTMLDivElement> | null | undefined;
    }>;
} & {
    style?: TreeItemCSSProperties | undefined;
}, "ref"> & {
    value?: string | undefined;
    itemType: TreeItemType;
} & React_2.RefAttributes<HTMLDivElement>> & (<Value = string>(props: TreeItemProps<Value>) => JSX.Element);

/**
 * TreeItemAside component - represents a custom set of actionable elements that will be visible when a certain
 * `TreeItem` is currently "active".
 */
export declare const TreeItemAside: ForwardRefComponent<TreeItemAsideProps>;

export declare const treeItemAsideClassNames: SlotClassNames<TreeItemAsideSlots>;

/**
 * TreeItemAside Props
 */
export declare type TreeItemAsideProps = ComponentProps<TreeItemAsideSlots> & {
    /**
     * boolean indicating if the aside content should behave as "actions"
     *
     * actionable elements are normally buttons, menus, or other focusable elements.
     * Those elements are only visibly available if the given tree item is currently active.
     */
    actions?: boolean;
    /**
     * Forces visibility of the aside content, even if they're actions
     */
    visible?: true;
};

export declare type TreeItemAsideSlots = {
    root: Slot<'div'>;
};

/**
 * State used in rendering TreeItemAside
 */
export declare type TreeItemAsideState = ComponentState<TreeItemAsideSlots> & {
    actions: boolean;
    visible: boolean;
    buttonContextValue: ButtonContextValue;
};

export declare const treeItemClassNames: SlotClassNames<TreeItemSlots>;

declare type TreeItemContextValue = {
    isActionsVisible: boolean;
    isAsideVisible: boolean;
    actionsRef: React_2.Ref<HTMLDivElement>;
    expandIconRef: React_2.Ref<HTMLDivElement>;
    layoutRef: React_2.Ref<HTMLDivElement>;
    subtreeRef: React_2.Ref<HTMLDivElement>;
    value: unknown;
    itemType: TreeItemType;
    open: boolean;
};

declare type TreeItemContextValues = {
    treeItem: TreeItemContextValue;
};

declare type TreeItemCSSProperties = React_2.CSSProperties & {
    [treeItemLevelToken]?: string | number;
};

/**
 * The `TreeItemLayout` component is used as a child of `TreeItem` to define the content and layout of a tree item.
 * It provides a consistent visual structure for tree items in a `Tree` component.
 * This component should only be used as a direct child of `TreeItem`.
 */
export declare const TreeItemLayout: ForwardRefComponent<TreeItemLayoutProps>;

export declare const treeItemLayoutClassNames: SlotClassNames<TreeItemLayoutSlots>;

/**
 * TreeItemLayout Props
 */
export declare type TreeItemLayoutProps = ComponentProps<Partial<TreeItemLayoutSlots>>;

export declare type TreeItemLayoutSlots = {
    root: Slot<'div'>;
    /**
     * Expand icon slot,
     * by default renders a chevron icon to indicate opening and closing
     */
    expandIcon?: Slot<'div'>;
    /**
     * Icon slot that renders right before main content
     */
    iconBefore?: Slot<'div'>;
    /**
     * Icon slot that renders right after main content
     */
    iconAfter?: Slot<'div'>;
};

/**
 * State used in rendering TreeItemLayout
 */
export declare type TreeItemLayoutState = ComponentState<TreeItemLayoutSlots>;

export declare const treeItemLevelToken: "--fluent-TreeItem--level";

/**
 * The `TreeItemPersonaLayout` component is used as a child of `TreeItem` to display a `TreeItem` with a media (typically an avatar) and a description.
 * It provides a more visually appealing representation of a `TreeItem` and is typically used to display a list of people or topics.
 * This component should only be used as a direct child of `TreeItem`.
 */
export declare const TreeItemPersonaLayout: ForwardRefComponent<TreeItemPersonaLayoutProps>;

export declare const treeItemPersonaLayoutClassNames: SlotClassNames<TreeItemPersonaLayoutSlots>;

declare type TreeItemPersonaLayoutContextValues = {
    avatar: AvatarContextValue;
};

/**
 * TreeItemPersonaLayout Props
 */
export declare type TreeItemPersonaLayoutProps = ComponentProps<Partial<TreeItemPersonaLayoutSlots>>;

export declare type TreeItemPersonaLayoutSlots = {
    root: NonNullable<Slot<'div'>>;
    /**
     * Expand icon slot,
     * by default renders a chevron icon to indicate opening and closing
     */
    expandIcon?: Slot<'div'>;
    /**
     * Avatar to display.
     */
    media: NonNullable<Slot<'div'>>;
    /**
     * Main text. Children of the root slot are automatically rendered here
     */
    main: NonNullable<Slot<'div'>>;
    /**
     * Secondary text that describes or complements the main text
     */
    description?: Slot<'div'>;
    /**
     * A layout wrapper for the main and description slots
     */
    content: NonNullable<Slot<'div'>>;
};

/**
 * State used in rendering TreeItemPersonaLayout
 */
export declare type TreeItemPersonaLayoutState = ComponentState<TreeItemPersonaLayoutSlots> & {
    avatarSize: AvatarSize;
};

/**
 * TreeItem Props
 */
export declare type TreeItemProps<Value = string> = ComponentProps<Partial<TreeItemSlots>> & {
    value?: Value;
    itemType: TreeItemType;
};

export declare const TreeItemProvider: React_2.Provider<TreeItemContextValue | undefined> & React_2.FC<React_2.ProviderProps<TreeItemContextValue | undefined>>;

declare type TreeItemRequest<Value> = {
    itemType: TreeItemType;
} & (OmitWithoutExpanding<TreeOpenChangeData<Value>, 'open' | 'target'> | OmitWithoutExpanding<TreeNavigationData_unstable<Value>, 'target'>);

export declare type TreeItemSlots = {
    root: Slot<ExtractSlotProps<Slot<'div'> & {
        style?: TreeItemCSSProperties;
    }>>;
};

/**
 * State used in rendering TreeItem
 */
export declare type TreeItemState = ComponentState<TreeItemSlots> & TreeItemContextValue & {
    level: number;
    itemType: TreeItemType;
};

declare type TreeItemType = 'leaf' | 'branch';

export declare type TreeNavigationData_unstable<Value = string> = {
    value: Value;
    target: HTMLElement;
} & ({
    event: React_2.MouseEvent<HTMLElement>;
    type: 'Click';
} | {
    event: React_2.KeyboardEvent<HTMLElement>;
    type: 'TypeAhead';
} | {
    event: React_2.KeyboardEvent<HTMLElement>;
    type: typeof ArrowRight;
} | {
    event: React_2.KeyboardEvent<HTMLElement>;
    type: typeof ArrowLeft;
} | {
    event: React_2.KeyboardEvent<HTMLElement>;
    type: typeof ArrowUp;
} | {
    event: React_2.KeyboardEvent<HTMLElement>;
    type: typeof ArrowDown;
} | {
    event: React_2.KeyboardEvent<HTMLElement>;
    type: typeof Home;
} | {
    event: React_2.KeyboardEvent<HTMLElement>;
    type: typeof End;
});

export declare type TreeNavigationEvent_unstable = TreeNavigationData_unstable['event'];

export declare type TreeOpenChangeData<Value = string> = {
    open: boolean;
    value: Value;
} & ({
    event: React_2.MouseEvent<HTMLElement>;
    target: HTMLElement;
    type: 'ExpandIconClick';
} | {
    event: React_2.MouseEvent<HTMLElement>;
    target: HTMLElement;
    type: 'Click';
} | {
    event: React_2.KeyboardEvent<HTMLElement>;
    target: HTMLElement;
    type: typeof Enter;
} | {
    event: React_2.KeyboardEvent<HTMLElement>;
    target: HTMLElement;
    type: typeof ArrowRight;
} | {
    event: React_2.KeyboardEvent<HTMLElement>;
    target: HTMLElement;
    type: typeof ArrowLeft;
});

export declare type TreeOpenChangeEvent = TreeOpenChangeData['event'];

export declare type TreeProps<Value = string> = ComponentProps<TreeSlots> & {
    /**
     * A tree item can have various appearances:
     * - 'subtle' (default): The default tree item styles.
     * - 'subtle-alpha': Minimizes emphasis on hovered or focused states.
     * - 'transparent': Removes background color.
     * @default 'subtle'
     */
    appearance?: 'subtle' | 'subtle-alpha' | 'transparent';
    /**
     * Size of the tree item.
     * @default 'medium'
     */
    size?: 'small' | 'medium';
    /**
     * This refers to a list of ids of opened tree items.
     * Controls the state of the open tree items.
     * These property is ignored for subtrees.
     */
    openItems?: Iterable<Value>;
    /**
     * This refers to a list of ids of opened tree items.
     * Default value for the uncontrolled state of open tree items.
     * These property is ignored for subtrees.
     */
    defaultOpenItems?: Iterable<Value>;
    /**
     * Callback fired when the component changes value from open state.
     * These property is ignored for subtrees.
     *
     * @param event - a React's Synthetic event
     * @param data - A data object with relevant information,
     * such as open value and type of interaction that created the event.
     */
    onOpenChange?(event: TreeOpenChangeEvent, data: TreeOpenChangeData<Value>): void;
    /**
     * Callback fired when navigation happens inside the component.
     * These property is ignored for subtrees.
     *
     * FIXME: This method is not ideal, as navigation should be handled internally by tabster.
     *
     * @param event - a React's Synthetic event
     * @param data - A data object with relevant information,
     */
    onNavigation_unstable?(event: TreeNavigationEvent_unstable, data: TreeNavigationData_unstable<Value>): void;
};

export declare const TreeProvider: Provider<TreeContextValue | undefined> & FC<ProviderProps<TreeContextValue | undefined>>;

export declare type TreeSlots = {
    root: Slot<'div'>;
};

/**
 * State used in rendering Tree
 */
export declare type TreeState = ComponentState<TreeSlots> & TreeContextValue & {
    open: boolean;
};

/**
 * this hook provides FlatTree API to manage all required mechanisms to convert a list of items into renderable TreeItems
 * in multiple scenarios including virtualization.
 *
 * !!A flat tree is an unofficial spec for tree!!
 *
 * It should be used on cases where more complex interactions with a Tree is required.
 * On simple scenarios it is advised to simply use a nested structure instead.
 *
 * @param flatTreeItemProps - a list of tree items
 * @param options - in case control over the internal openItems is required
 */
export declare function useFlatTree_unstable<Props extends FlatTreeItemProps<unknown> = FlatTreeItemProps>(flatTreeItemProps: Props[], options?: FlatTreeOptions<Props>): FlatTree<Props>;

/**
 * Create the state required to render Tree.
 *
 * The returned state can be modified with hooks such as useTreeStyles_unstable,
 * before being passed to renderTree_unstable.
 *
 * @param props - props from this instance of Tree
 * @param ref - reference to root HTMLElement of Tree
 */
export declare const useTree_unstable: (props: TreeProps, ref: React_2.Ref<HTMLElement>) => TreeState;

export declare const useTreeContext_unstable: <T>(selector: ContextSelector<TreeContextValue, T>) => T;

export declare function useTreeContextValues_unstable(state: TreeState): TreeContextValues;

/**
 * Create the state required to render TreeItem.
 *
 * The returned state can be modified with hooks such as useTreeItemStyles_unstable,
 * before being passed to renderTreeItem_unstable.
 *
 * @param props - props from this instance of TreeItem
 * @param ref - reference to root HTMLElement of TreeItem
 */
export declare function useTreeItem_unstable<Value = string>(props: TreeItemProps<Value>, ref: React_2.Ref<HTMLDivElement>): TreeItemState;

/**
 * Create the state required to render TreeItemAside.
 *
 * The returned state can be modified with hooks such as useTreeItemAsideStyles_unstable,
 * before being passed to renderTreeItemAside_unstable.
 *
 * @param props - props from this instance of TreeItemAside
 * @param ref - reference to root HTMLElement of TreeItemAside
 */
export declare const useTreeItemAside_unstable: (props: TreeItemAsideProps, ref: React_2.Ref<HTMLElement>) => TreeItemAsideState;

/**
 * Apply styling to the TreeItemAside slots based on the state
 */
export declare const useTreeItemAsideStyles_unstable: (state: TreeItemAsideState) => TreeItemAsideState;

export declare const useTreeItemContext_unstable: <T>(selector: ContextSelector<TreeItemContextValue, T>) => T;

/**
 * Create the state required to render TreeItemLayout.
 *
 * The returned state can be modified with hooks such as useTreeItemLayoutStyles_unstable,
 * before being passed to renderTreeItemLayout_unstable.
 *
 * @param props - props from this instance of TreeItemLayout
 * @param ref - reference to root HTMLElement of TreeItemLayout
 */
export declare const useTreeItemLayout_unstable: (props: TreeItemLayoutProps, ref: React_2.Ref<HTMLElement>) => TreeItemLayoutState;

/**
 * Apply styling to the TreeItemLayout slots based on the state
 */
export declare const useTreeItemLayoutStyles_unstable: (state: TreeItemLayoutState) => TreeItemLayoutState;

/**
 * Create the state required to render TreeItemPersonaLayout.
 *
 * The returned state can be modified with hooks such as useTreeItemPersonaLayoutStyles_unstable,
 * before being passed to renderTreeItemPersonaLayout_unstable.
 *
 * @param props - props from this instance of TreeItemPersonaLayout
 * @param ref - reference to root HTMLElement of TreeItemPersonaLayout
 */
export declare const useTreeItemPersonaLayout_unstable: (props: TreeItemPersonaLayoutProps, ref: React_2.Ref<HTMLSpanElement>) => TreeItemPersonaLayoutState;

/**
 * Apply styling to the TreeItemPersonaLayout slots based on the state
 */
export declare const useTreeItemPersonaLayoutStyles_unstable: (state: TreeItemPersonaLayoutState) => TreeItemPersonaLayoutState;

/**
 * Apply styling to the TreeItem slots based on the state
 */
export declare const useTreeItemStyles_unstable: (state: TreeItemState) => TreeItemState;

export declare const useTreeStyles_unstable: (state: TreeState) => TreeState;

export { }
